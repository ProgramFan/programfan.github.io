<h1>User-local python packages install with pip</h1>
<div class="sect1">
<h2 id="motivation">Motivation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>PyENV has done a fairly good job in managing user-local python versions, as well as per-version pip packages. However, some packages such as PyQt5 need deep system integration and can not be installed using pip. This makes packages such as jupyter-qtconsole upset. The use of shims in PyENV also forces any provided command to be started with a shell script (so a shell process). This makes packages such as python-powerline much slower.</p>
</div>
<div class="paragraph">
<p>To solve the above problems, I choose to go back to the standard python user-local install process and choose pip user install. pip user install relys on system python to work correctly, and integrates tightly with system packages. That is to say, if one install PyQt5 using system package manager, he/she can use it in a user-local toyplot package, avoiding install PyQt5 manually (since not possible with pip). Moreover, binaries provided by packages are directly avaliable to the system, which greatly improves the speed of packages such as python-powerline <span class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="instructions">Instructions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>pip user install is good. Then how we do it? It&#8217;s as easy as following the listed steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the user install location, say <code>$MYINSTALL</code>. By default, it&#8217;s
<code>$HOME/.local</code>.</p>
</li>
<li>
<p>Install packages we want using the following command:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span class="tok-nv">PYTHONUSERBASE</span><span class="tok-o">=</span><span class="tok-nv">$MYINSTALL</span> pip install --user --upgrade &lt;PACKAGES&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>Setup python path and binary path</p>
<div class="listingblock">
<div class="content">
<pre>export PYTHONPATH=$MYINSTALL:$PYTHONPATH
export PATH=$MYINSTALL/bin:$PATH</pre>
</div>
</div>
</li>
<li>
<p>Enjoy.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integrate-with-system-packages">Integrate with system packages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you install packages such as numpy, scipy and matplotlib with system package manager, and then install packages such as toyplot or jupyter, you may find that numpy, scipy will not be upgraded since the requirements of toyplot is already meet. This is the power of local install, which integrates well with existing packages.</p>
</div>
<div class="paragraph">
<p>But if you do want a more recent version that system provided, you can append <code>--upgrade</code> to <code>pip install</code>.</p>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a> python-powerline uses a binary powerline-client to accelerate shell prompt rendering, which is much more responsive than shell scripts. The latter causes visiable lag even on recent ivebridge CPUs.
</div>
</div>